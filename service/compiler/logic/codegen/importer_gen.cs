
using System.Collections.Generic;
using System.IO;
using System;

public static class Program {

  private static void w(params string[] s) {
    if (s == null) return;
    for (int i = 0; i < s.Length; i++) {
      Console.Write(s[i]);
    }
  }

  private static void wl(params string[] s) {
    w(s);
    Console.WriteLine();
  }

  public static void Main() {
    wl();
    wl("\' This file is generated by importer_gen and definition.txt.");
    wl("\' Do not edit.");
    wl();
    wl("Option Explicit On");
    wl("Option Infer Off");
    wl("Option Strict On");
    wl();
    wl("Imports osi.root.connector");
    wl("Imports osi.root.constants");
    wl("Imports osi.root.formation");
    wl("Imports osi.service.interpreter.primitive");
    wl();
    wl("Partial Public NotInheritable Class logic");
    wl("    Partial Public NotInheritable Class importer");
    List<string> keys = new List<string>();
    string s;
    while ((s = Console.ReadLine()) != null) {
      s = s.Trim();
      if (string.IsNullOrWhiteSpace(s) || s[0] == '#') {
        continue;
      }
      string[] ss = s.Split('\t');
      keys.Add(ss[0]);
      wl("        Private Function parse_" + ss[0] + "_" + (keys.Count - 1).ToString() + "(");
      wl("                ByVal v As vector(Of String),");
      wl("                ByRef p As UInt32,");
      wl("                ByRef o As instruction_gen) As Boolean");
      wl("            assert(Not v Is Nothing)");
      wl("            assert(v.size() > p)");
      wl("            If Not v(p).Equals(\"" + ss[0] + "\") Then");
      wl("                Return False");
      wl("            End If");
      wl("            Dim start As UInt32 = p");
      wl("            p += uint32_1");
      for (int i = 1; i < ss.Length; i++) {
        wl("            If Not v.available_index(p) Then");
        wl("                Return False");
        wl("            End If");
        switch(ss[i]) {
          case "string":
            wl("            Dim p" + i.ToString() + " As String = v(p)");
            break;
          case "uint":
            wl("            Dim p" + i.ToString() + " As UInt32 = 0");
            wl("            If Not UInt32.TryParse(v(p), p" + i.ToString() + ") Then");
            wl("                Return False");
            wl("            End If");
            break;
          case "data_block":
            wl("            Dim p" + i.ToString() + " As New data_block()");
            wl("            Dim new_pos As UInt32 = p");
            wl("            If Not p" + i.ToString() + ".import(v, new_pos) Then");
            wl("                Return False");
            wl("            End If");
            wl("            assert(new_pos = p + uint32_1)");
            break;
          case "parameters":
            wl("            Dim p" + i.ToString() + " As New vector(Of String)()");
            wl("            If Not parse_parameters(p" + i.ToString() + ", v, p) Then");
            wl("                Return False");
            wl("            End If");
            wl("            p -= uint32_1");
            break;
          case "typed_parameters":
            wl("            Dim p" + i.ToString() + " As New vector(Of pair(Of String, String))()");
            wl("            If Not parse_typed_parameters(p" + i.ToString() + ", v, p) Then");
            wl("                Return False");
            wl("            End If");
            wl("            p -= uint32_1");
            break;
          case "paragraph":
            wl("            Dim p" + i.ToString() + " As paragraph = Nothing");
            wl("            If Not parse_paragraph(p" + i.ToString() + ", v, p) Then");
            wl("                Return False");
            wl("            End If");
            wl("            p -= uint32_1");
            break;
          default:
            wl("            Dim p" + i.ToString() + " As place_holder = Nothing");
            wl("            If Not v(p).Equals(\"" + ss[i] + "\") Then");
            wl("                Return False");
            wl("            End If");
            break;
        }
        wl("            p += uint32_1");
      }
      wl("            o = New _" + ss[0] + "(");
      for (int i = 1; i < ss.Length; i++) {
        w("                p" + i.ToString());
        if (i < ss.Length - 1) {
          wl(",");
        } else {
          wl();
        }
      }
      wl("            )");
      wl("            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)");
      wl("            Return True");
      wl("        End Function");
      wl();
    }
    wl("        Private Function parse(ByVal v As vector(Of String),");
    wl("                               ByRef p As UInt32,");
    wl("                               ByRef o As instruction_gen) As Boolean");
    wl("            If v Is Nothing OrElse v.size() <= p Then");
    wl("                Return False");
    wl("            End If");
    for (int i = 0; i < keys.Count; i++) {
      wl("            Using code_block");
      wl("                Dim pos As UInt32 = p");
      wl("                If parse_" + keys[i] + "_" + i.ToString() + "(v, pos, o) Then");
      wl("                    p = pos");
      wl("                    Return True");
      wl("                End If");
      wl("            End Using");
    }
    wl("            errors.unexpected_token(v(p))");
    wl("            Return False");
    wl("        End Function");
    wl("    End Class");
    wl("End Class");
  }
}
