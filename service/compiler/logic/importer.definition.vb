
' This file is generated by importer_gen and definition.txt.
' Do not edit.

Option Explicit On
Option Infer Off
Option Strict On

Imports osi.root.connector
Imports osi.root.constants
Imports osi.root.formation
Imports osi.service.interpreter.primitive

Namespace logic
    Partial Public NotInheritable Class importer
        Private Function parse_start_scope_0(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("start_scope") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As paragraph = Nothing
            If Not parse_paragraph(p1, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _start_scope(
                p1
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_type_1(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("type") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As UInt32 = 0
            If Not UInt32.TryParse(v(p), p2) Then
                Return False
            End If
            p += uint32_1
            o = New _type(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_append_slice_2(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("append_slice") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _append_slice(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_cut_slice_3(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("cut_slice") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _cut_slice(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_cut_4(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("cut") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _cut(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_cut_len_5(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("cut_len") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p4 As String = v(p)
            p += uint32_1
            o = New _cut_len(
                p1,
                p2,
                p3,
                p4
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_clear_6(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("clear") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            o = New _clear(
                p1
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_add_7(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("add") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _add(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_subtract_8(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("subtract") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _subtract(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_multiply_9(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("multiply") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _multiply(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_divide_10(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("divide") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p4 As String = v(p)
            p += uint32_1
            o = New _divide(
                p1,
                p2,
                p3,
                p4
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_extract_11(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("extract") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p4 As String = v(p)
            p += uint32_1
            o = New _extract(
                p1,
                p2,
                p3,
                p4
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_power_12(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("power") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _power(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_and_13(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("and") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _and(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_or_14(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("or") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _or(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_callee_15(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("callee") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As New vector(Of pair(Of String, String))()
            If Not parse_typed_parameters(p3, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p4 As paragraph = Nothing
            If Not parse_paragraph(p4, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _callee(
                p1,
                p2,
                p3,
                p4
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_caller_16(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("caller") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As New vector(Of String)()
            If Not parse_parameters(p3, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _caller(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_caller_17(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("caller") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As New vector(Of String)()
            If Not parse_parameters(p2, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _caller(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_callee_ref_18(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("callee_ref") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As New vector(Of String)()
            If Not parse_parameters(p3, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _callee_ref(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_caller_ref_19(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("caller_ref") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As New vector(Of String)()
            If Not parse_parameters(p3, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _caller_ref(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_caller_ref_20(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("caller_ref") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As New vector(Of String)()
            If Not parse_parameters(p2, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _caller_ref(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_address_of_21(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("address_of") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _address_of(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_less_22(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("less") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _less(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_more_23(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("more") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _more(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_equal_24(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("equal") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _equal(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_less_or_equal_25(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("less_or_equal") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _less_or_equal(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_more_or_equal_26(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("more_or_equal") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _more_or_equal(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_if_27(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("if") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As paragraph = Nothing
            If Not parse_paragraph(p2, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As place_holder = Nothing
            If Not v(p).Equals("else") Then
                Return False
            End If
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p4 As paragraph = Nothing
            If Not parse_paragraph(p4, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _if(
                p1,
                p2,
                p3,
                p4
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_if_28(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("if") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As paragraph = Nothing
            If Not parse_paragraph(p2, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _if(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_copy_29(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("copy") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _copy(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_copy_const_30(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("copy_const") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As New data_block()
            Dim new_pos As UInt32 = p
            If Not p2.import(v, new_pos) Then
                Return False
            End If
            assert(new_pos = p + uint32_1)
            p += uint32_1
            o = New _copy_const(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_define_31(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("define") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _define(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_define_heap_32(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("define_heap") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _define_heap(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_do_until_33(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("do_until") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As paragraph = Nothing
            If Not parse_paragraph(p2, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _do_until(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_do_while_34(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("do_while") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As paragraph = Nothing
            If Not parse_paragraph(p2, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _do_while(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_interrupt_35(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("interrupt") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _interrupt(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_move_36(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("move") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _move(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_return_37(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("return") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As place_holder = Nothing
            If Not v(p).Equals("*") Then
                Return False
            End If
            p += uint32_1
            o = New _return(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_return_38(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("return") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _return(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_append_39(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("append") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _append(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_not_40(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("not") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _not(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_sizeof_41(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("sizeof") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _sizeof(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_empty_42(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("empty") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            o = New _empty(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_while_then_43(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("while_then") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As paragraph = Nothing
            If Not parse_paragraph(p2, v, p) Then
                Return False
            End If
            p -= uint32_1
            p += uint32_1
            o = New _while_then(
                p1,
                p2
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_stop_44(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("stop") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            o = New _stop(
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_add_45(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_add") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_add(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_subtract_46(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_subtract") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_subtract(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_multiply_47(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_multiply") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_multiply(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_divide_48(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_divide") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_divide(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_extract_49(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_extract") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_extract(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_power_50(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_power") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_power(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_less_51(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_less") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_less(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_more_52(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_more") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_more(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_equal_53(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_equal") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_equal(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_less_or_equal_54(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_less_or_equal") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_less_or_equal(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_float_more_or_equal_55(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("float_more_or_equal") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _float_more_or_equal(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_left_shift_56(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("left_shift") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _left_shift(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse_right_shift_57(
                ByVal v As vector(Of String),
                ByRef p As UInt32,
                ByRef o As instruction_gen) As Boolean
            assert(v IsNot Nothing)
            assert(v.size() > p)
            If Not v(p).Equals("right_shift") Then
                Return False
            End If
            Dim start As UInt32 = p
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p1 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p2 As String = v(p)
            p += uint32_1
            If Not v.available_index(p) Then
                Return False
            End If
            Dim p3 As String = v(p)
            p += uint32_1
            o = New _right_shift(
                p1,
                p2,
                p3
            )
            o = instruction_gen_wrapper.maybe_wrap(v, start, p, o)
            Return True
        End Function

        Private Function parse(ByVal v As vector(Of String),
                               ByRef p As UInt32,
                               ByRef o As instruction_gen) As Boolean
            If v Is Nothing OrElse v.size() <= p Then
                Return False
            End If
            Using code_block
                Dim pos As UInt32 = p
                If parse_start_scope_0(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_type_1(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_append_slice_2(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_cut_slice_3(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_cut_4(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_cut_len_5(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_clear_6(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_add_7(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_subtract_8(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_multiply_9(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_divide_10(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_extract_11(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_power_12(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_and_13(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_or_14(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_callee_15(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_caller_16(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_caller_17(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_callee_ref_18(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_caller_ref_19(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_caller_ref_20(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_address_of_21(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_less_22(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_more_23(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_equal_24(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_less_or_equal_25(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_more_or_equal_26(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_if_27(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_if_28(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_copy_29(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_copy_const_30(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_define_31(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_define_heap_32(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_do_until_33(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_do_while_34(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_interrupt_35(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_move_36(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_return_37(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_return_38(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_append_39(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_not_40(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_sizeof_41(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_empty_42(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_while_then_43(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_stop_44(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_add_45(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_subtract_46(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_multiply_47(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_divide_48(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_extract_49(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_power_50(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_less_51(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_more_52(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_equal_53(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_less_or_equal_54(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_float_more_or_equal_55(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_left_shift_56(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            Using code_block
                Dim pos As UInt32 = p
                If parse_right_shift_57(v, pos, o) Then
                    p = pos
                    Return True
                End If
            End Using
            errors.unexpected_token(v(p))
            Return False
        End Function
    End Class
End Namespace
