
#ifndef B2STYLE_LIB_STD_VECTOR
#define B2STYLE_LIB_STD_VECTOR

#include <b2style.h>
#include <assert.h>
#include <bstyle/heap.h>
#include <std/types.h>

namespace std {

template <T>
class vector {
  heap_ptr _a;
  int _s;
  int _c;

  int size() {
    return this._s;
  }

  int capacity() {
    return this._c;
  }

  T get(int index) {
    ::assert(index >= 0, "get");
    ::assert(index < this.size(), "get");
    reinterpret_cast(this._a, T);
    return this._a[index]; 
  }

  void set(int index, T v) {
    ::assert(index >= 0, "set");
    ::assert(index < this.size(), "set");
    reinterpret_cast(this._a, T);
    this._a[index] = v;
  }

  void destruct() {
    ::bstyle::dealloc(this._a);
  }

  void reserve(int size) {
    heap_ptr x;
    ::bstyle::alloc(x, size);
    for (int i = 0; i < this.size(); i++) {
      x[i] = this.get(i);
    }
	::bstyle::dealloc(this._a);
    this._a = x;
    this._c = size;
  }

  void construct(int size) {
    this._a = ::bstyle::npos();
    this.reserve(size);
  }

  void construct() {
    this.construct(4);
  }

  void push_back(T v) {
    if (this.size() == this.capacity()) {
      this.reserve(this.capacity() << 1);
    }
    this._s++;
    this.set(this.size() - 1, v);
  }

  void pop_back() {
    ::assert(this.size() > 0, "pop_back");
    this._s--;
  }

  void clear() {
    this._s = 0;
  }
};

}  // namespace std

#endif  // B2STYLE_LIB_STD_VECTOR