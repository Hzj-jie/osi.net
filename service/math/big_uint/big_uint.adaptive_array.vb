'this file is generated by /osi/root/codegen/adaptive_array/adaptive_array.exe
'so change /osi/root/codegen/adaptive_array/adaptive_array.cs instead of this file
'usually you do not need to use this codegen and the code generated unless it's in a very strict performance related code
'use vector is a better way, while the implementation of vector is also using the code generated by this codegen
'p.s. this file needs to work with osi.root.connector project

Imports osi.root
Imports osi.root.connector
Imports osi.root.constants

Partial Public Class big_uint
Private Class adaptive_array_uint32
    Implements ICloneable, ICloneable(Of adaptive_array_uint32), IComparable(Of adaptive_array_uint32), IComparable

    Private Const size_limitation As UInt32 = (max_uint32 >> 1)
    Private Shared ReadOnly default_value As UInt32 = Nothing

    Private Shared Function expected_capacity(ByVal n As UInt32) As UInt32
        If n <= 2 Then
            Return 4
        Else
            Return n << 1
        End If
    End Function

    Private d() As UInt32
    Private s As UInt32

    Public Sub New()
    End Sub

    Public Sub New(ByVal n As UInt32)
        reserve(n)
    End Sub

    Public Shared Function move(ByVal that As adaptive_array_uint32) As adaptive_array_uint32
        If that Is Nothing Then
            Return Nothing
        End If

        Dim r As adaptive_array_uint32 = Nothing
        r = New adaptive_array_uint32()
        r.d = that.d
        r.s = that.s
        that.d = Nothing
        that.s = 0
        Return r
    End Function

    Public Shared Function swap(ByVal this As adaptive_array_uint32, ByVal that As adaptive_array_uint32) As Boolean
        If this Is Nothing OrElse that Is Nothing Then
            Return False
        Else
            connector.swap(this.d, that.d)
            connector.swap(this.s, that.s)
            Return True
        End If
    End Function

    Public Function replace_by(ByVal d() As UInt32, ByVal s As UInt32) As Boolean
        If array_size(d) >= s Then
            Me.d = d
            Me.s = s
            Return True
        Else
            Return False
        End If
    End Function

    Public Sub replace_by(ByVal d() As UInt32)
        assert(replace_by(d, array_size(d)))
    End Sub

    Public Function max_size() As UInt32
        Return size_limitation
    End Function

    Public Function data() As UInt32()
        Return d
    End Function

    Default Public Property at(ByVal p As UInt32) As UInt32
        Get
            Return d(p)
        End Get
        Set(ByVal value As UInt32)
            d(p) = value
        End Set
    End Property

    Public Function [get](ByVal p As UInt32) As UInt32
        Return d(p)
    End Function

    Public Sub [set](ByVal p As UInt32, ByVal v As UInt32)
        d(p) = v
    End Sub

    Public Function size() As UInt32
        Return s
    End Function

    Public Function empty() As Boolean
        Return size() = uint32_0
    End Function

    Public Function capacity() As UInt32
        Return array_size(d)
    End Function

    Public Function back() As UInt32
        Return d(size() - uint32_1)
    End Function

    Public Sub clear()
        If size() > uint32_0 Then
            memclr(d, uint32_0, s)
            s = uint32_0
        End If
    End Sub

    Public Sub push_back(ByVal v As UInt32)
        reserve(size() + uint32_1)
        d(size()) = v
        s += uint32_1
    End Sub

    Public Sub pop_back()
        s -= uint32_1
        d(size()) = default_value
    End Sub

    Public Sub reserve(ByVal n As UInt32)
        If capacity() < n Then
            If empty() Then
                ReDim d(expected_capacity(n) - uint32_1)
            Else
                ReDim Preserve d(expected_capacity(n) - uint32_1)
            End If
        End If
    End Sub

    Public Sub resize(ByVal n As UInt32)
        If capacity() < n Then
            reserve(n)
        ElseIf size() > n Then
            memclr(d, n, size() - n)
        End If
        s = n
    End Sub

    Public Sub resize(ByVal n As UInt32, ByVal v As UInt32)
        Dim os As UInt32 = 0
        os = size()
        If n > os Then
            resize(n)
            memset(d, os, n - os, v)
        Else
            resize(n)
        End If
    End Sub

    Public Sub shrink_to_fit()
        If empty() Then
            ReDim d(-1)
        ElseIf capacity() > size() Then
            ReDim Preserve d(size() - uint32_1)
        End If
    End Sub

    Public Function Clone() As Object Implements ICloneable.Clone
        Return CloneT()
    End Function

    Public Function CloneT() As adaptive_array_uint32 Implements ICloneable(Of adaptive_array_uint32).Clone
        Dim r As adaptive_array_uint32 = Nothing
        r = New adaptive_array_uint32()
        r.d = deep_clone(d)
        r.s = s
        Return r
    End Function

    Public Shared Function compare(ByVal this As adaptive_array_uint32, ByVal that As adaptive_array_uint32) As Int32
        Dim c As Int32 = 0
        c = object_compare(this, that)
        If c <> object_compare_undetermined Then
            Return c
        End If
        assert(Not this Is Nothing)
        assert(Not that Is Nothing)
        If this.size() < that.size() Then
            Return -1
        ElseIf this.size() > that.size() Then
            Return 1
        Else
            Return deep_compare(this.d, that.d, this.size())
        End If
    End Function

    Public Function CompareTo(ByVal obj As Object) As Int32 Implements IComparable.CompareTo
        Return CompareTo(cast(Of adaptive_array_uint32)(obj, False))
    End Function

    Public Function CompareTo(ByVal other As adaptive_array_uint32) As Int32 Implements IComparable(Of adaptive_array_uint32).CompareTo
        Return compare(Me, other)
    End Function

End Class
End Class
