
Imports osi.root.connector

Public NotInheritable Class ##TYPE##(Of KEY_T, VALUE_T)
    Inherits ##BASE_TYPE##(Of first_const_pair(Of KEY_T, VALUE_T))
    Implements ICloneable, ICloneable(Of ##TYPE##(Of KEY_T, VALUE_T))

    Shared Sub New()
        container_operator(Of ##TYPE##(Of KEY_T, VALUE_T), first_const_pair(Of KEY_T, VALUE_T)).size(
                Function(ByVal i As ##TYPE##(Of KEY_T, VALUE_T)) As UInt32
                    assert(Not i Is Nothing)
                    Return i.size()
                End Function)
        container_operator.emplace(Function(ByVal i As ##TYPE##(Of KEY_T, VALUE_T),
                                            ByVal j As first_const_pair(Of KEY_T, VALUE_T)) As Boolean
                                       assert(Not i Is Nothing)
                                       Return i.emplace(j).second
                                   End Function)
        container_operator.enumerate(Function(ByVal i As ##TYPE##(Of KEY_T, VALUE_T)) _
                                             As container_operator(Of ##TYPE##(Of KEY_T, VALUE_T),
                                                                      first_const_pair(Of KEY_T, VALUE_T)).enumerator
                                         Return New enumerator(i)
                                     End Function)
        container_operator(Of ##TYPE##(Of KEY_T, VALUE_T), first_const_pair(Of KEY_T, VALUE_T)).clear(
                Sub(ByVal i As ##TYPE##(Of KEY_T, VALUE_T))
                    assert(Not i Is Nothing)
                    i.clear()
                End Sub)
        bytes_serializer(Of ##TYPE##(Of KEY_T, VALUE_T)).container(Of first_const_pair(Of KEY_T, VALUE_T)).register()
    End Sub

    Private NotInheritable Class enumerator
        Implements container_operator(Of ##TYPE##(Of KEY_T, VALUE_T), first_const_pair(Of KEY_T, VALUE_T)).enumerator

        Private it As ##TYPE##(Of KEY_T, VALUE_T).iterator

        Public Sub New(ByVal m As ##TYPE##(Of KEY_T, VALUE_T))
            assert(Not m Is Nothing)
            it = m.begin()
        End Sub

        Public Sub [next]() Implements container_operator(Of ##TYPE##(Of KEY_T, VALUE_T),
                                                             first_const_pair(Of KEY_T, VALUE_T)).enumerator.next
            it += 1
        End Sub

        Public Function current() As first_const_pair(Of KEY_T, VALUE_T) _
                Implements container_operator(Of ##TYPE##(Of KEY_T, VALUE_T),
                                                 first_const_pair(Of KEY_T, VALUE_T)).enumerator.current
            Return +it
        End Function

        Public Function [end]() As Boolean _
                Implements container_operator(Of ##TYPE##(Of KEY_T, VALUE_T),
                                                 first_const_pair(Of KEY_T, VALUE_T)).enumerator.end
            Return it.is_end()
        End Function
    End Class

    Public Sub New()
        MyBase.New(AddressOf first_compare)
    End Sub

    Private Shared Function first_compare(ByVal this As first_const_pair(Of KEY_T, VALUE_T),
                                          ByVal that As first_const_pair(Of KEY_T, VALUE_T)) As Int32
        Dim c As Int32 = 0
        c = object_compare(this, that)
        If c = object_compare_undetermined Then
            assert(Not this Is Nothing)
            assert(Not that Is Nothing)
            Return connector.compare(this.first, that.first)
        Else
            Return c
        End If
    End Function

    Public Shared Shadows Function move(ByVal v As ##TYPE##(Of KEY_T, VALUE_T)) As ##TYPE##(Of KEY_T, VALUE_T)
        If v Is Nothing Then
            Return Nothing
        Else
            Dim r As ##TYPE##(Of KEY_T, VALUE_T) = Nothing
            r = New ##TYPE##(Of KEY_T, VALUE_T)()
            move_to(v, r)
            Return r
        End If
    End Function

    Public Shadows Function clone() As ##TYPE##(Of KEY_T, VALUE_T)
        Dim r As ##TYPE##(Of KEY_T, VALUE_T) = Nothing
        r = New ##TYPE##(Of KEY_T, VALUE_T)()
        clone_to(Me, r)
        Return r
    End Function

    Public Function CloneT() As ##TYPE##(Of KEY_T, VALUE_T) Implements ICloneable(Of ##TYPE##(Of KEY_T, VALUE_T)).Clone
        Return clone()
    End Function

    Public Function ICloneable_Clone() As Object Implements ICloneable.Clone
        Return clone()
    End Function

    Public Overloads Function emplace(ByVal key As KEY_T,
                                      ByVal value As VALUE_T) As pair(Of iterator, Boolean)
        Return MyBase.emplace(emplace_make_first_const_pair(key, value))
    End Function

    Public Overloads Function insert(ByVal key As KEY_T,
                                     ByVal value As VALUE_T) As pair(Of iterator, Boolean)
        Return emplace(copy_no_error(key), copy_no_error(value))
    End Function

    Public Shadows Function [erase](ByVal it As iterator) As Boolean
        Return MyBase.erase(it)
    End Function

    Public Shadows Function [erase](ByVal key As KEY_T) As Boolean
        Return MyBase.erase(find(key))
    End Function

    Public Shadows Function find(ByVal key As KEY_T) As iterator
        Return MyBase.find(emplace_make_first_const_pair(Of KEY_T, VALUE_T)(key))
    End Function

    Default Public Property at(ByVal key As KEY_T) As VALUE_T
        Get
            Dim r As iterator = Nothing
            r = find(key)
            If r = [end]() Then
                r = emplace(copy_no_error(key), alloc(Of VALUE_T)()).first
            End If
            Return (+r).second
        End Get
        Set(ByVal value As VALUE_T)
            Dim r As pair(Of iterator, Boolean) = Nothing
            r = insert(key, value)
            If Not r.second Then
                copy(r.first.value().second, value)
            End If
        End Set
    End Property
End Class
