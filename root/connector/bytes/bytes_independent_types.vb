
' TODO Remove
'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types.vbp ----------
'so change bytes_independent_types.vbp instead of this file


Option Strict On

Imports System.Runtime.CompilerServices
Imports osi.root.constants

Public Module _bytes_independent_types


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("byte" = "byte")

    Public Function bytes_byte(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Byte) As Boolean
        If il <> sizeof_byte OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToByte(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function byte_bytes(ByVal i As Byte) As Byte()
#If IS_BYTE Then
        assert(sizeof_byte = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_byte
#End If
        If bytes_byte(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "byte" = "uint32" Then
    Public Function bytes_byte_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Byte
#Else
    Public Function bytes_byte(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Byte
#End If
        Dim o As Byte = byte_0
        assert(bytes_byte(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte) As Boolean
        Dim p As UInt32 = 0
        Return bytes_byte(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_byte(ByVal i() As Byte) As Byte
        Dim o As Byte = byte_0
        assert(entire_bytes_byte(i, o))
        Return o
    End Function
    
    Public Function byte_bytes(
                        ByVal i As Byte,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_byte
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = byte_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "byte" <> "int8" AndAlso "byte" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As Byte) As Byte()
        Return byte_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_byte(ByVal i() As Byte) As Byte
#If "byte" = "uint32" Then
        Return bytes_byte_(i)
#Else
        Return bytes_byte(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("byte" <> "single" AndAlso "byte" <> "double") Then
    Public Function big_endian_bytes_byte(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Byte) As Boolean
        If il <> sizeof_byte OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_byte(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_byte) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_byte(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function byte_big_endian_bytes(ByVal i As Byte) As Byte()
#If IS_BYTE Then
        assert(sizeof_byte = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = byte_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_byte) - 1)
            For j As Int32 = CInt(sizeof_byte) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return byte_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_byte
#End If
        If big_endian_bytes_byte(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "byte" = "uint32" Then
    Public Function big_endian_bytes_byte_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Byte
#Else
    Public Function big_endian_bytes_byte(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Byte
#End If
        Dim o As Byte = byte_0
        assert(big_endian_bytes_byte(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_byte(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_byte(ByVal i() As Byte) As Byte
        Dim o As Byte = byte_0
        assert(entire_big_endian_bytes_byte(i, o))
        Return o
    End Function
    
    Public Function byte_big_endian_bytes(
                        ByVal i As Byte,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_byte
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = byte_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "byte" <> "int8" AndAlso "byte" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As Byte) As Byte()
        Return byte_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_byte(ByVal i() As Byte) As Byte
#If "byte" = "uint32" Then
        Return big_endian_bytes_byte_(i)
#Else
        Return big_endian_bytes_byte(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_byte(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Byte) As Boolean
        If il <> sizeof_byte OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_byte(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_byte) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_byte(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function byte_little_endian_bytes(ByVal i As Byte) As Byte()
#If IS_BYTE Then
        assert(sizeof_byte = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = byte_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_byte))
            For j As Int32 = 0 To CInt(sizeof_byte) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return byte_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_byte
#End If
        If little_endian_bytes_byte(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "byte" = "uint32" Then
    Public Function little_endian_bytes_byte_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Byte
#Else
    Public Function little_endian_bytes_byte(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Byte
#End If
        Dim o As Byte = byte_0
        assert(little_endian_bytes_byte(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_byte(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_byte(ByVal i() As Byte) As Byte
        Dim o As Byte = byte_0
        assert(entire_little_endian_bytes_byte(i, o))
        Return o
    End Function
    
    Public Function byte_little_endian_bytes(
                        ByVal i As Byte,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_byte
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = byte_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "byte" <> "int8" AndAlso "byte" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As Byte) As Byte()
        Return byte_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_byte(ByVal i() As Byte) As Byte
#If "byte" = "uint32" Then
        Return little_endian_bytes_byte_(i)
#Else
        Return little_endian_bytes_byte(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("int16" = "byte")

    Public Function bytes_int16(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int16) As Boolean
        If il <> sizeof_int16 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToInt16(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function int16_bytes(ByVal i As Int16) As Byte()
#If IS_BYTE Then
        assert(sizeof_int16 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int16
#End If
        If bytes_int16(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int16" = "uint32" Then
    Public Function bytes_int16_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int16
#Else
    Public Function bytes_int16(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int16
#End If
        Dim o As Int16 = int16_0
        assert(bytes_int16(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16) As Boolean
        Dim p As UInt32 = 0
        Return bytes_int16(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_int16(ByVal i() As Byte) As Int16
        Dim o As Int16 = int16_0
        assert(entire_bytes_int16(i, o))
        Return o
    End Function
    
    Public Function int16_bytes(
                        ByVal i As Int16,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int16
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int16_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int16" <> "int8" AndAlso "int16" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As Int16) As Byte()
        Return int16_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_int16(ByVal i() As Byte) As Int16
#If "int16" = "uint32" Then
        Return bytes_int16_(i)
#Else
        Return bytes_int16(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("int16" <> "single" AndAlso "int16" <> "double") Then
    Public Function big_endian_bytes_int16(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int16) As Boolean
        If il <> sizeof_int16 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_int16(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_int16) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_int16(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function int16_big_endian_bytes(ByVal i As Int16) As Byte()
#If IS_BYTE Then
        assert(sizeof_int16 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = int16_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_int16) - 1)
            For j As Int32 = CInt(sizeof_int16) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return int16_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int16
#End If
        If big_endian_bytes_int16(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int16" = "uint32" Then
    Public Function big_endian_bytes_int16_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int16
#Else
    Public Function big_endian_bytes_int16(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int16
#End If
        Dim o As Int16 = int16_0
        assert(big_endian_bytes_int16(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_int16(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_int16(ByVal i() As Byte) As Int16
        Dim o As Int16 = int16_0
        assert(entire_big_endian_bytes_int16(i, o))
        Return o
    End Function
    
    Public Function int16_big_endian_bytes(
                        ByVal i As Int16,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int16
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int16_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int16" <> "int8" AndAlso "int16" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As Int16) As Byte()
        Return int16_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_int16(ByVal i() As Byte) As Int16
#If "int16" = "uint32" Then
        Return big_endian_bytes_int16_(i)
#Else
        Return big_endian_bytes_int16(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_int16(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int16) As Boolean
        If il <> sizeof_int16 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_int16(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_int16) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_int16(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function int16_little_endian_bytes(ByVal i As Int16) As Byte()
#If IS_BYTE Then
        assert(sizeof_int16 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = int16_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_int16))
            For j As Int32 = 0 To CInt(sizeof_int16) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return int16_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int16
#End If
        If little_endian_bytes_int16(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int16" = "uint32" Then
    Public Function little_endian_bytes_int16_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int16
#Else
    Public Function little_endian_bytes_int16(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int16
#End If
        Dim o As Int16 = int16_0
        assert(little_endian_bytes_int16(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_int16(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_int16(ByVal i() As Byte) As Int16
        Dim o As Int16 = int16_0
        assert(entire_little_endian_bytes_int16(i, o))
        Return o
    End Function
    
    Public Function int16_little_endian_bytes(
                        ByVal i As Int16,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int16
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int16_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int16" <> "int8" AndAlso "int16" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As Int16) As Byte()
        Return int16_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_int16(ByVal i() As Byte) As Int16
#If "int16" = "uint32" Then
        Return little_endian_bytes_int16_(i)
#Else
        Return little_endian_bytes_int16(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("uint16" = "byte")

    Public Function bytes_uint16(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt16) As Boolean
        If il <> sizeof_uint16 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToUInt16(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function uint16_bytes(ByVal i As UInt16) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint16 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_uint16(
                        ByVal i() As Byte,
                        ByRef o As UInt16,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint16
#End If
        If bytes_uint16(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint16" = "uint32" Then
    Public Function bytes_uint16_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt16
#Else
    Public Function bytes_uint16(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt16
#End If
        Dim o As UInt16 = uint16_0
        assert(bytes_uint16(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_uint16(
                        ByVal i() As Byte,
                        ByRef o As UInt16) As Boolean
        Dim p As UInt32 = 0
        Return bytes_uint16(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_uint16(ByVal i() As Byte) As UInt16
        Dim o As UInt16 = uint16_0
        assert(entire_bytes_uint16(i, o))
        Return o
    End Function
    
    Public Function uint16_bytes(
                        ByVal i As UInt16,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint16
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint16_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint16" <> "int8" AndAlso "uint16" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As UInt16) As Byte()
        Return uint16_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_uint16(ByVal i() As Byte) As UInt16
#If "uint16" = "uint32" Then
        Return bytes_uint16_(i)
#Else
        Return bytes_uint16(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("uint16" <> "single" AndAlso "uint16" <> "double") Then
    Public Function big_endian_bytes_uint16(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt16) As Boolean
        If il <> sizeof_uint16 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_uint16(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_uint16) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_uint16(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function uint16_big_endian_bytes(ByVal i As UInt16) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint16 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = uint16_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_uint16) - 1)
            For j As Int32 = CInt(sizeof_uint16) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return uint16_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_uint16(
                        ByVal i() As Byte,
                        ByRef o As UInt16,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint16
#End If
        If big_endian_bytes_uint16(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint16" = "uint32" Then
    Public Function big_endian_bytes_uint16_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt16
#Else
    Public Function big_endian_bytes_uint16(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt16
#End If
        Dim o As UInt16 = uint16_0
        assert(big_endian_bytes_uint16(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_uint16(
                        ByVal i() As Byte,
                        ByRef o As UInt16) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_uint16(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_uint16(ByVal i() As Byte) As UInt16
        Dim o As UInt16 = uint16_0
        assert(entire_big_endian_bytes_uint16(i, o))
        Return o
    End Function
    
    Public Function uint16_big_endian_bytes(
                        ByVal i As UInt16,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint16
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint16_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint16" <> "int8" AndAlso "uint16" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As UInt16) As Byte()
        Return uint16_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_uint16(ByVal i() As Byte) As UInt16
#If "uint16" = "uint32" Then
        Return big_endian_bytes_uint16_(i)
#Else
        Return big_endian_bytes_uint16(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_uint16(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt16) As Boolean
        If il <> sizeof_uint16 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_uint16(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_uint16) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_uint16(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function uint16_little_endian_bytes(ByVal i As UInt16) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint16 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = uint16_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_uint16))
            For j As Int32 = 0 To CInt(sizeof_uint16) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return uint16_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_uint16(
                        ByVal i() As Byte,
                        ByRef o As UInt16,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint16
#End If
        If little_endian_bytes_uint16(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint16" = "uint32" Then
    Public Function little_endian_bytes_uint16_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt16
#Else
    Public Function little_endian_bytes_uint16(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt16
#End If
        Dim o As UInt16 = uint16_0
        assert(little_endian_bytes_uint16(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_uint16(
                        ByVal i() As Byte,
                        ByRef o As UInt16) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_uint16(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_uint16(ByVal i() As Byte) As UInt16
        Dim o As UInt16 = uint16_0
        assert(entire_little_endian_bytes_uint16(i, o))
        Return o
    End Function
    
    Public Function uint16_little_endian_bytes(
                        ByVal i As UInt16,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint16
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint16_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint16" <> "int8" AndAlso "uint16" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As UInt16) As Byte()
        Return uint16_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_uint16(ByVal i() As Byte) As UInt16
#If "uint16" = "uint32" Then
        Return little_endian_bytes_uint16_(i)
#Else
        Return little_endian_bytes_uint16(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("int32" = "byte")

    Public Function bytes_int32(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int32) As Boolean
        If il <> sizeof_int32 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToInt32(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function int32_bytes(ByVal i As Int32) As Byte()
#If IS_BYTE Then
        assert(sizeof_int32 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int32
#End If
        If bytes_int32(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int32" = "uint32" Then
    Public Function bytes_int32_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int32
#Else
    Public Function bytes_int32(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int32
#End If
        Dim o As Int32 = int32_0
        assert(bytes_int32(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32) As Boolean
        Dim p As UInt32 = 0
        Return bytes_int32(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_int32(ByVal i() As Byte) As Int32
        Dim o As Int32 = int32_0
        assert(entire_bytes_int32(i, o))
        Return o
    End Function
    
    Public Function int32_bytes(
                        ByVal i As Int32,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int32
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int32_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int32" <> "int8" AndAlso "int32" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As Int32) As Byte()
        Return int32_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_int32(ByVal i() As Byte) As Int32
#If "int32" = "uint32" Then
        Return bytes_int32_(i)
#Else
        Return bytes_int32(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("int32" <> "single" AndAlso "int32" <> "double") Then
    Public Function big_endian_bytes_int32(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int32) As Boolean
        If il <> sizeof_int32 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_int32(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_int32) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_int32(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function int32_big_endian_bytes(ByVal i As Int32) As Byte()
#If IS_BYTE Then
        assert(sizeof_int32 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = int32_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_int32) - 1)
            For j As Int32 = CInt(sizeof_int32) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return int32_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int32
#End If
        If big_endian_bytes_int32(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int32" = "uint32" Then
    Public Function big_endian_bytes_int32_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int32
#Else
    Public Function big_endian_bytes_int32(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int32
#End If
        Dim o As Int32 = int32_0
        assert(big_endian_bytes_int32(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_int32(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_int32(ByVal i() As Byte) As Int32
        Dim o As Int32 = int32_0
        assert(entire_big_endian_bytes_int32(i, o))
        Return o
    End Function
    
    Public Function int32_big_endian_bytes(
                        ByVal i As Int32,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int32
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int32_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int32" <> "int8" AndAlso "int32" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As Int32) As Byte()
        Return int32_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_int32(ByVal i() As Byte) As Int32
#If "int32" = "uint32" Then
        Return big_endian_bytes_int32_(i)
#Else
        Return big_endian_bytes_int32(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_int32(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int32) As Boolean
        If il <> sizeof_int32 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_int32(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_int32) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_int32(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function int32_little_endian_bytes(ByVal i As Int32) As Byte()
#If IS_BYTE Then
        assert(sizeof_int32 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = int32_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_int32))
            For j As Int32 = 0 To CInt(sizeof_int32) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return int32_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int32
#End If
        If little_endian_bytes_int32(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int32" = "uint32" Then
    Public Function little_endian_bytes_int32_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int32
#Else
    Public Function little_endian_bytes_int32(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int32
#End If
        Dim o As Int32 = int32_0
        assert(little_endian_bytes_int32(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_int32(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_int32(ByVal i() As Byte) As Int32
        Dim o As Int32 = int32_0
        assert(entire_little_endian_bytes_int32(i, o))
        Return o
    End Function
    
    Public Function int32_little_endian_bytes(
                        ByVal i As Int32,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int32
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int32_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int32" <> "int8" AndAlso "int32" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As Int32) As Byte()
        Return int32_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_int32(ByVal i() As Byte) As Int32
#If "int32" = "uint32" Then
        Return little_endian_bytes_int32_(i)
#Else
        Return little_endian_bytes_int32(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("uint32" = "byte")

    Public Function bytes_uint32(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt32) As Boolean
        If il <> sizeof_uint32 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToUInt32(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function uint32_bytes(ByVal i As UInt32) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint32 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_uint32(
                        ByVal i() As Byte,
                        ByRef o As UInt32,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint32
#End If
        If bytes_uint32(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint32" = "uint32" Then
    Public Function bytes_uint32_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt32
#Else
    Public Function bytes_uint32(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt32
#End If
        Dim o As UInt32 = uint32_0
        assert(bytes_uint32(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_uint32(
                        ByVal i() As Byte,
                        ByRef o As UInt32) As Boolean
        Dim p As UInt32 = 0
        Return bytes_uint32(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_uint32(ByVal i() As Byte) As UInt32
        Dim o As UInt32 = uint32_0
        assert(entire_bytes_uint32(i, o))
        Return o
    End Function
    
    Public Function uint32_bytes(
                        ByVal i As UInt32,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint32
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint32_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint32" <> "int8" AndAlso "uint32" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As UInt32) As Byte()
        Return uint32_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_uint32(ByVal i() As Byte) As UInt32
#If "uint32" = "uint32" Then
        Return bytes_uint32_(i)
#Else
        Return bytes_uint32(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("uint32" <> "single" AndAlso "uint32" <> "double") Then
    Public Function big_endian_bytes_uint32(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt32) As Boolean
        If il <> sizeof_uint32 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_uint32(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_uint32) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_uint32(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function uint32_big_endian_bytes(ByVal i As UInt32) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint32 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = uint32_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_uint32) - 1)
            For j As Int32 = CInt(sizeof_uint32) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return uint32_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_uint32(
                        ByVal i() As Byte,
                        ByRef o As UInt32,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint32
#End If
        If big_endian_bytes_uint32(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint32" = "uint32" Then
    Public Function big_endian_bytes_uint32_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt32
#Else
    Public Function big_endian_bytes_uint32(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt32
#End If
        Dim o As UInt32 = uint32_0
        assert(big_endian_bytes_uint32(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_uint32(
                        ByVal i() As Byte,
                        ByRef o As UInt32) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_uint32(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_uint32(ByVal i() As Byte) As UInt32
        Dim o As UInt32 = uint32_0
        assert(entire_big_endian_bytes_uint32(i, o))
        Return o
    End Function
    
    Public Function uint32_big_endian_bytes(
                        ByVal i As UInt32,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint32
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint32_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint32" <> "int8" AndAlso "uint32" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As UInt32) As Byte()
        Return uint32_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_uint32(ByVal i() As Byte) As UInt32
#If "uint32" = "uint32" Then
        Return big_endian_bytes_uint32_(i)
#Else
        Return big_endian_bytes_uint32(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_uint32(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt32) As Boolean
        If il <> sizeof_uint32 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_uint32(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_uint32) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_uint32(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function uint32_little_endian_bytes(ByVal i As UInt32) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint32 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = uint32_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_uint32))
            For j As Int32 = 0 To CInt(sizeof_uint32) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return uint32_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_uint32(
                        ByVal i() As Byte,
                        ByRef o As UInt32,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint32
#End If
        If little_endian_bytes_uint32(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint32" = "uint32" Then
    Public Function little_endian_bytes_uint32_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt32
#Else
    Public Function little_endian_bytes_uint32(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt32
#End If
        Dim o As UInt32 = uint32_0
        assert(little_endian_bytes_uint32(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_uint32(
                        ByVal i() As Byte,
                        ByRef o As UInt32) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_uint32(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_uint32(ByVal i() As Byte) As UInt32
        Dim o As UInt32 = uint32_0
        assert(entire_little_endian_bytes_uint32(i, o))
        Return o
    End Function
    
    Public Function uint32_little_endian_bytes(
                        ByVal i As UInt32,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint32
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint32_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint32" <> "int8" AndAlso "uint32" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As UInt32) As Byte()
        Return uint32_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_uint32(ByVal i() As Byte) As UInt32
#If "uint32" = "uint32" Then
        Return little_endian_bytes_uint32_(i)
#Else
        Return little_endian_bytes_uint32(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("int64" = "byte")

    Public Function bytes_int64(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int64) As Boolean
        If il <> sizeof_int64 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToInt64(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function int64_bytes(ByVal i As Int64) As Byte()
#If IS_BYTE Then
        assert(sizeof_int64 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int64
#End If
        If bytes_int64(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int64" = "uint32" Then
    Public Function bytes_int64_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int64
#Else
    Public Function bytes_int64(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int64
#End If
        Dim o As Int64 = int64_0
        assert(bytes_int64(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64) As Boolean
        Dim p As UInt32 = 0
        Return bytes_int64(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_int64(ByVal i() As Byte) As Int64
        Dim o As Int64 = int64_0
        assert(entire_bytes_int64(i, o))
        Return o
    End Function
    
    Public Function int64_bytes(
                        ByVal i As Int64,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int64
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int64_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int64" <> "int8" AndAlso "int64" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As Int64) As Byte()
        Return int64_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_int64(ByVal i() As Byte) As Int64
#If "int64" = "uint32" Then
        Return bytes_int64_(i)
#Else
        Return bytes_int64(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("int64" <> "single" AndAlso "int64" <> "double") Then
    Public Function big_endian_bytes_int64(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int64) As Boolean
        If il <> sizeof_int64 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_int64(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_int64) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_int64(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function int64_big_endian_bytes(ByVal i As Int64) As Byte()
#If IS_BYTE Then
        assert(sizeof_int64 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = int64_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_int64) - 1)
            For j As Int32 = CInt(sizeof_int64) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return int64_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int64
#End If
        If big_endian_bytes_int64(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int64" = "uint32" Then
    Public Function big_endian_bytes_int64_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int64
#Else
    Public Function big_endian_bytes_int64(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int64
#End If
        Dim o As Int64 = int64_0
        assert(big_endian_bytes_int64(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_int64(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_int64(ByVal i() As Byte) As Int64
        Dim o As Int64 = int64_0
        assert(entire_big_endian_bytes_int64(i, o))
        Return o
    End Function
    
    Public Function int64_big_endian_bytes(
                        ByVal i As Int64,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int64
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int64_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int64" <> "int8" AndAlso "int64" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As Int64) As Byte()
        Return int64_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_int64(ByVal i() As Byte) As Int64
#If "int64" = "uint32" Then
        Return big_endian_bytes_int64_(i)
#Else
        Return big_endian_bytes_int64(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_int64(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int64) As Boolean
        If il <> sizeof_int64 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_int64(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_int64) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_int64(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function int64_little_endian_bytes(ByVal i As Int64) As Byte()
#If IS_BYTE Then
        assert(sizeof_int64 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = int64_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_int64))
            For j As Int32 = 0 To CInt(sizeof_int64) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return int64_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int64
#End If
        If little_endian_bytes_int64(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int64" = "uint32" Then
    Public Function little_endian_bytes_int64_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int64
#Else
    Public Function little_endian_bytes_int64(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int64
#End If
        Dim o As Int64 = int64_0
        assert(little_endian_bytes_int64(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_int64(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_int64(ByVal i() As Byte) As Int64
        Dim o As Int64 = int64_0
        assert(entire_little_endian_bytes_int64(i, o))
        Return o
    End Function
    
    Public Function int64_little_endian_bytes(
                        ByVal i As Int64,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_int64
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = int64_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "int64" <> "int8" AndAlso "int64" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As Int64) As Byte()
        Return int64_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_int64(ByVal i() As Byte) As Int64
#If "int64" = "uint32" Then
        Return little_endian_bytes_int64_(i)
#Else
        Return little_endian_bytes_int64(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("uint64" = "byte")

    Public Function bytes_uint64(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt64) As Boolean
        If il <> sizeof_uint64 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToUInt64(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function uint64_bytes(ByVal i As UInt64) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint64 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_uint64(
                        ByVal i() As Byte,
                        ByRef o As UInt64,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint64
#End If
        If bytes_uint64(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint64" = "uint32" Then
    Public Function bytes_uint64_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt64
#Else
    Public Function bytes_uint64(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt64
#End If
        Dim o As UInt64 = uint64_0
        assert(bytes_uint64(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_uint64(
                        ByVal i() As Byte,
                        ByRef o As UInt64) As Boolean
        Dim p As UInt32 = 0
        Return bytes_uint64(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_uint64(ByVal i() As Byte) As UInt64
        Dim o As UInt64 = uint64_0
        assert(entire_bytes_uint64(i, o))
        Return o
    End Function
    
    Public Function uint64_bytes(
                        ByVal i As UInt64,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint64
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint64_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint64" <> "int8" AndAlso "uint64" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As UInt64) As Byte()
        Return uint64_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_uint64(ByVal i() As Byte) As UInt64
#If "uint64" = "uint32" Then
        Return bytes_uint64_(i)
#Else
        Return bytes_uint64(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("uint64" <> "single" AndAlso "uint64" <> "double") Then
    Public Function big_endian_bytes_uint64(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt64) As Boolean
        If il <> sizeof_uint64 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_uint64(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_uint64) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_uint64(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function uint64_big_endian_bytes(ByVal i As UInt64) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint64 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = uint64_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_uint64) - 1)
            For j As Int32 = CInt(sizeof_uint64) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return uint64_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_uint64(
                        ByVal i() As Byte,
                        ByRef o As UInt64,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint64
#End If
        If big_endian_bytes_uint64(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint64" = "uint32" Then
    Public Function big_endian_bytes_uint64_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt64
#Else
    Public Function big_endian_bytes_uint64(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt64
#End If
        Dim o As UInt64 = uint64_0
        assert(big_endian_bytes_uint64(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_uint64(
                        ByVal i() As Byte,
                        ByRef o As UInt64) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_uint64(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_uint64(ByVal i() As Byte) As UInt64
        Dim o As UInt64 = uint64_0
        assert(entire_big_endian_bytes_uint64(i, o))
        Return o
    End Function
    
    Public Function uint64_big_endian_bytes(
                        ByVal i As UInt64,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint64
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint64_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint64" <> "int8" AndAlso "uint64" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As UInt64) As Byte()
        Return uint64_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_uint64(ByVal i() As Byte) As UInt64
#If "uint64" = "uint32" Then
        Return big_endian_bytes_uint64_(i)
#Else
        Return big_endian_bytes_uint64(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_uint64(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As UInt64) As Boolean
        If il <> sizeof_uint64 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_uint64(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_uint64) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_uint64(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function uint64_little_endian_bytes(ByVal i As UInt64) As Byte()
#If IS_BYTE Then
        assert(sizeof_uint64 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = uint64_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_uint64))
            For j As Int32 = 0 To CInt(sizeof_uint64) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return uint64_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_uint64(
                        ByVal i() As Byte,
                        ByRef o As UInt64,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint64
#End If
        If little_endian_bytes_uint64(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint64" = "uint32" Then
    Public Function little_endian_bytes_uint64_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt64
#Else
    Public Function little_endian_bytes_uint64(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As UInt64
#End If
        Dim o As UInt64 = uint64_0
        assert(little_endian_bytes_uint64(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_uint64(
                        ByVal i() As Byte,
                        ByRef o As UInt64) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_uint64(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_uint64(ByVal i() As Byte) As UInt64
        Dim o As UInt64 = uint64_0
        assert(entire_little_endian_bytes_uint64(i, o))
        Return o
    End Function
    
    Public Function uint64_little_endian_bytes(
                        ByVal i As UInt64,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_uint64
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = uint64_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "uint64" <> "int8" AndAlso "uint64" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As UInt64) As Byte()
        Return uint64_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_uint64(ByVal i() As Byte) As UInt64
#If "uint64" = "uint32" Then
        Return little_endian_bytes_uint64_(i)
#Else
        Return little_endian_bytes_uint64(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("single" = "byte")

    Public Function bytes_single(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Single) As Boolean
        If il <> sizeof_single OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToSingle(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function single_bytes(ByVal i As Single) As Byte()
#If IS_BYTE Then
        assert(sizeof_single = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_single
#End If
        If bytes_single(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "single" = "uint32" Then
    Public Function bytes_single_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Single
#Else
    Public Function bytes_single(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Single
#End If
        Dim o As Single = single_0
        assert(bytes_single(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single) As Boolean
        Dim p As UInt32 = 0
        Return bytes_single(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_single(ByVal i() As Byte) As Single
        Dim o As Single = single_0
        assert(entire_bytes_single(i, o))
        Return o
    End Function
    
    Public Function single_bytes(
                        ByVal i As Single,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_single
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = single_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "single" <> "int8" AndAlso "single" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As Single) As Byte()
        Return single_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_single(ByVal i() As Byte) As Single
#If "single" = "uint32" Then
        Return bytes_single_(i)
#Else
        Return bytes_single(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("single" <> "single" AndAlso "single" <> "double") Then
    Public Function big_endian_bytes_single(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Single) As Boolean
        If il <> sizeof_single OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_single(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_single) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_single(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function single_big_endian_bytes(ByVal i As Single) As Byte()
#If IS_BYTE Then
        assert(sizeof_single = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = single_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_single) - 1)
            For j As Int32 = CInt(sizeof_single) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return single_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_single
#End If
        If big_endian_bytes_single(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "single" = "uint32" Then
    Public Function big_endian_bytes_single_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Single
#Else
    Public Function big_endian_bytes_single(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Single
#End If
        Dim o As Single = single_0
        assert(big_endian_bytes_single(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_single(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_single(ByVal i() As Byte) As Single
        Dim o As Single = single_0
        assert(entire_big_endian_bytes_single(i, o))
        Return o
    End Function
    
    Public Function single_big_endian_bytes(
                        ByVal i As Single,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_single
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = single_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "single" <> "int8" AndAlso "single" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As Single) As Byte()
        Return single_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_single(ByVal i() As Byte) As Single
#If "single" = "uint32" Then
        Return big_endian_bytes_single_(i)
#Else
        Return big_endian_bytes_single(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_single(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Single) As Boolean
        If il <> sizeof_single OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_single(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_single) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_single(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function single_little_endian_bytes(ByVal i As Single) As Byte()
#If IS_BYTE Then
        assert(sizeof_single = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = single_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_single))
            For j As Int32 = 0 To CInt(sizeof_single) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return single_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_single
#End If
        If little_endian_bytes_single(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "single" = "uint32" Then
    Public Function little_endian_bytes_single_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Single
#Else
    Public Function little_endian_bytes_single(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Single
#End If
        Dim o As Single = single_0
        assert(little_endian_bytes_single(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_single(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_single(ByVal i() As Byte) As Single
        Dim o As Single = single_0
        assert(entire_little_endian_bytes_single(i, o))
        Return o
    End Function
    
    Public Function single_little_endian_bytes(
                        ByVal i As Single,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_single
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = single_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "single" <> "int8" AndAlso "single" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As Single) As Byte()
        Return single_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_single(ByVal i() As Byte) As Single
#If "single" = "uint32" Then
        Return little_endian_bytes_single_(i)
#Else
        Return little_endian_bytes_single(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



' A manual loop is ~10% faster than reverse functions.
#Const USE_REVERSE = False
#Const IS_BYTE = ("double" = "byte")

    Public Function bytes_double(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Double) As Boolean
        If il <> sizeof_double OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToDouble(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function double_bytes(ByVal i As Double) As Byte()
#If IS_BYTE Then
        assert(sizeof_double = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_double
#End If
        If bytes_double(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "double" = "uint32" Then
    Public Function bytes_double_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Double
#Else
    Public Function bytes_double(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Double
#End If
        Dim o As Double = double_0
        assert(bytes_double(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double) As Boolean
        Dim p As UInt32 = 0
        Return bytes_double(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_double(ByVal i() As Byte) As Double
        Dim o As Double = double_0
        assert(entire_bytes_double(i, o))
        Return o
    End Function
    
    Public Function double_bytes(
                        ByVal i As Double,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_double
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = double_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "double" <> "int8" AndAlso "double" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function bytes(ByVal i As Double) As Byte()
        Return double_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_double(ByVal i() As Byte) As Double
#If "double" = "uint32" Then
        Return bytes_double_(i)
#Else
        Return bytes_double(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

#If ("double" <> "single" AndAlso "double" <> "double") Then
    Public Function big_endian_bytes_double(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Double) As Boolean
        If il <> sizeof_double OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_double(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = 0 To CInt(sizeof_double) - 1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_double(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function double_big_endian_bytes(ByVal i As Double) As Byte()
#If IS_BYTE Then
        assert(sizeof_double = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = double_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_double) - 1)
            For j As Int32 = CInt(sizeof_double) - 1 To 0 Step -1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return double_bytes(i)
        End If
#End If
    End Function


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function big_endian_bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_double
#End If
        If big_endian_bytes_double(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "double" = "uint32" Then
    Public Function big_endian_bytes_double_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Double
#Else
    Public Function big_endian_bytes_double(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Double
#End If
        Dim o As Double = double_0
        assert(big_endian_bytes_double(i, o, offset))
        Return o
    End Function

    Public Function entire_big_endian_bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double) As Boolean
        Dim p As UInt32 = 0
        Return big_endian_bytes_double(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_big_endian_bytes_double(ByVal i() As Byte) As Double
        Dim o As Double = double_0
        assert(entire_big_endian_bytes_double(i, o))
        Return o
    End Function
    
    Public Function double_big_endian_bytes(
                        ByVal i As Double,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_double
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = double_big_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "double" <> "int8" AndAlso "double" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function big_endian_bytes(ByVal i As Double) As Byte()
        Return double_big_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_big_endian_double(ByVal i() As Byte) As Double
#If "double" = "uint32" Then
        Return big_endian_bytes_double_(i)
#Else
        Return big_endian_bytes_double(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------

    Public Function little_endian_bytes_double(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Double) As Boolean
        If il <> sizeof_double OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
                assert(bytes_double(i, ii, il, o))
                o = endian.reverse(o)
#Else
                o = 0
                For j As Int32 = CInt(sizeof_double) - 1 To 0 Step -1
                    o <<= bit_count_in_byte
                    o += i(j)
                Next
#End If
            Else
                assert(bytes_double(i, ii, il, o))
            End If
#End If
            Return True
        End If
    End Function

    Public Function double_little_endian_bytes(ByVal i As Double) As Byte()
#If IS_BYTE Then
        assert(sizeof_double = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        If Not BitConverter.IsLittleEndian Then
#If USE_REVERSE Then
            Dim o() As Byte = Nothing
            o = double_bytes(i)
            o.in_place_reverse()
            Return o
#Else
            Dim o() As Byte = Nothing
            ReDim o(CInt(sizeof_double))
            For j As Int32 = 0 To CInt(sizeof_double) - 1
                o(j) = CByte(i And max_uint8)
                i >>= bit_count_in_byte
            Next
            Return o
#End If
        Else
            Return double_bytes(i)
        End If
#End If
    End Function

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_dependent_impl.vbp ----------
'so change bytes_dependent_impl.vbp instead of this file


    Public Function little_endian_bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_double
#End If
        If little_endian_bytes_double(i, offset, size, o) Then
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "double" = "uint32" Then
    Public Function little_endian_bytes_double_(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Double
#Else
    Public Function little_endian_bytes_double(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Double
#End If
        Dim o As Double = double_0
        assert(little_endian_bytes_double(i, o, offset))
        Return o
    End Function

    Public Function entire_little_endian_bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double) As Boolean
        Dim p As UInt32 = 0
        Return little_endian_bytes_double(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_little_endian_bytes_double(ByVal i() As Byte) As Double
        Dim o As Double = double_0
        assert(entire_little_endian_bytes_double(i, o))
        Return o
    End Function
    
    Public Function double_little_endian_bytes(
                        ByVal i As Double,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        Dim size As UInt32 = 0
#If "" <> "" Then
        size = sizeof_
#Else
        size = sizeof_double
#End If
        If array_size(d) >= offset + size Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
            Dim t() As Byte = Nothing
            t = double_little_endian_bytes(i)
            memcpy(d, offset, t)
#End If
            offset += size
            Return True
        Else
            Return False
        End If
    End Function

#If "double" <> "int8" AndAlso "double" <> "uint8" Then
    ' There are no int8 and uint8 types.
    <Extension()> Public Function little_endian_bytes(ByVal i As Double) As Byte()
        Return double_little_endian_bytes(i)
    End Function
#End If

    <Extension()> Public Function as_little_endian_double(ByVal i() As Byte) As Double
#If "double" = "uint32" Then
        Return little_endian_bytes_double_(i)
#Else
        Return little_endian_bytes_double(i)
#End If
    End Function
'finish bytes_dependent_impl.vbp --------
#End If
'finish bytes_independent_types_impl.vbp --------
End Module
'finish bytes_independent_types.vbp --------
