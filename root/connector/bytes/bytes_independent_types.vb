
'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types.vbp ----------
'so change bytes_independent_types.vbp instead of this file


Option Strict On

Imports osi.root.constants

Public Module _bytes_independent_types

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



#Const IS_BYTE = ("byte" = "byte")

    Public Function bytes_byte(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Byte) As Boolean
        If il <> sizeof_byte OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToByte(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(i) >= offset + sizeof_int8 Then
#If IS_BYTE Then
            o = i(CInt(offset))
#Else
            o = BitConverter.ToByte(i, CInt(offset))
#End If
            offset += sizeof_byte
            Return True
        Else
            Return False
        End If
    End Function

    Public Function bytes_byte(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Byte
        Dim o As Byte = 0
        assert(bytes_byte(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_byte(
                        ByVal i() As Byte,
                        ByRef o As Byte) As Boolean
        Dim p As UInt32 = 0
        Return bytes_byte(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_byte(ByVal i() As Byte) As Byte
        Dim o As Byte = 0
        assert(entire_bytes_byte(i, o))
        Return o
    End Function
    
    Public Function byte_bytes(
                        ByVal i As Byte,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(d) >= offset + sizeof_byte Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
#If 0 Then
            'for mono
            'Marshal.WriteXXX is 100% slower than BitConverter with memcpy
            Try
                Marshal.WriteByte(d, CInt(offset), i)
            Catch
                Dim t() As Byte = Nothing
                t = byte_bytes(i)
                memcpy(d, offset, t)
            End Try
#Else
            Dim t() As Byte = Nothing
            t = byte_bytes(i)
            memcpy(d, offset, t)
#End If
#End If
            offset += sizeof_byte
            Return True
        Else
            Return False
        End If
    End Function

    Public Function byte_bytes(ByVal i As Byte) As Byte()
#If IS_BYTE Then
        assert(sizeof_byte = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



#Const IS_BYTE = ("int16" = "byte")

    Public Function bytes_int16(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int16) As Boolean
        If il <> sizeof_int16 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToInt16(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(i) >= offset + sizeof_int8 Then
#If IS_BYTE Then
            o = i(CInt(offset))
#Else
            o = BitConverter.ToInt16(i, CInt(offset))
#End If
            offset += sizeof_int16
            Return True
        Else
            Return False
        End If
    End Function

    Public Function bytes_int16(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int16
        Dim o As Int16 = 0
        assert(bytes_int16(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_int16(
                        ByVal i() As Byte,
                        ByRef o As Int16) As Boolean
        Dim p As UInt32 = 0
        Return bytes_int16(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_int16(ByVal i() As Byte) As Int16
        Dim o As Int16 = 0
        assert(entire_bytes_int16(i, o))
        Return o
    End Function
    
    Public Function int16_bytes(
                        ByVal i As Int16,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(d) >= offset + sizeof_int16 Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
#If 0 Then
            'for mono
            'Marshal.WriteXXX is 100% slower than BitConverter with memcpy
            Try
                Marshal.WriteInt16(d, CInt(offset), i)
            Catch
                Dim t() As Byte = Nothing
                t = int16_bytes(i)
                memcpy(d, offset, t)
            End Try
#Else
            Dim t() As Byte = Nothing
            t = int16_bytes(i)
            memcpy(d, offset, t)
#End If
#End If
            offset += sizeof_int16
            Return True
        Else
            Return False
        End If
    End Function

    Public Function int16_bytes(ByVal i As Int16) As Byte()
#If IS_BYTE Then
        assert(sizeof_int16 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



#Const IS_BYTE = ("int32" = "byte")

    Public Function bytes_int32(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int32) As Boolean
        If il <> sizeof_int32 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToInt32(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(i) >= offset + sizeof_int8 Then
#If IS_BYTE Then
            o = i(CInt(offset))
#Else
            o = BitConverter.ToInt32(i, CInt(offset))
#End If
            offset += sizeof_int32
            Return True
        Else
            Return False
        End If
    End Function

    Public Function bytes_int32(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int32
        Dim o As Int32 = 0
        assert(bytes_int32(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_int32(
                        ByVal i() As Byte,
                        ByRef o As Int32) As Boolean
        Dim p As UInt32 = 0
        Return bytes_int32(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_int32(ByVal i() As Byte) As Int32
        Dim o As Int32 = 0
        assert(entire_bytes_int32(i, o))
        Return o
    End Function
    
    Public Function int32_bytes(
                        ByVal i As Int32,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(d) >= offset + sizeof_int32 Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
#If 0 Then
            'for mono
            'Marshal.WriteXXX is 100% slower than BitConverter with memcpy
            Try
                Marshal.WriteInt32(d, CInt(offset), i)
            Catch
                Dim t() As Byte = Nothing
                t = int32_bytes(i)
                memcpy(d, offset, t)
            End Try
#Else
            Dim t() As Byte = Nothing
            t = int32_bytes(i)
            memcpy(d, offset, t)
#End If
#End If
            offset += sizeof_int32
            Return True
        Else
            Return False
        End If
    End Function

    Public Function int32_bytes(ByVal i As Int32) As Byte()
#If IS_BYTE Then
        assert(sizeof_int32 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



#Const IS_BYTE = ("int64" = "byte")

    Public Function bytes_int64(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Int64) As Boolean
        If il <> sizeof_int64 OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToInt64(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(i) >= offset + sizeof_int8 Then
#If IS_BYTE Then
            o = i(CInt(offset))
#Else
            o = BitConverter.ToInt64(i, CInt(offset))
#End If
            offset += sizeof_int64
            Return True
        Else
            Return False
        End If
    End Function

    Public Function bytes_int64(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Int64
        Dim o As Int64 = 0
        assert(bytes_int64(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_int64(
                        ByVal i() As Byte,
                        ByRef o As Int64) As Boolean
        Dim p As UInt32 = 0
        Return bytes_int64(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_int64(ByVal i() As Byte) As Int64
        Dim o As Int64 = 0
        assert(entire_bytes_int64(i, o))
        Return o
    End Function
    
    Public Function int64_bytes(
                        ByVal i As Int64,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(d) >= offset + sizeof_int64 Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
#If 0 Then
            'for mono
            'Marshal.WriteXXX is 100% slower than BitConverter with memcpy
            Try
                Marshal.WriteInt64(d, CInt(offset), i)
            Catch
                Dim t() As Byte = Nothing
                t = int64_bytes(i)
                memcpy(d, offset, t)
            End Try
#Else
            Dim t() As Byte = Nothing
            t = int64_bytes(i)
            memcpy(d, offset, t)
#End If
#End If
            offset += sizeof_int64
            Return True
        Else
            Return False
        End If
    End Function

    Public Function int64_bytes(ByVal i As Int64) As Byte()
#If IS_BYTE Then
        assert(sizeof_int64 = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



#Const IS_BYTE = ("single" = "byte")

    Public Function bytes_single(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Single) As Boolean
        If il <> sizeof_single OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToSingle(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(i) >= offset + sizeof_int8 Then
#If IS_BYTE Then
            o = i(CInt(offset))
#Else
            o = BitConverter.ToSingle(i, CInt(offset))
#End If
            offset += sizeof_single
            Return True
        Else
            Return False
        End If
    End Function

    Public Function bytes_single(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Single
        Dim o As Single = 0
        assert(bytes_single(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_single(
                        ByVal i() As Byte,
                        ByRef o As Single) As Boolean
        Dim p As UInt32 = 0
        Return bytes_single(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_single(ByVal i() As Byte) As Single
        Dim o As Single = 0
        assert(entire_bytes_single(i, o))
        Return o
    End Function
    
    Public Function single_bytes(
                        ByVal i As Single,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(d) >= offset + sizeof_single Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
#If 0 Then
            'for mono
            'Marshal.WriteXXX is 100% slower than BitConverter with memcpy
            Try
                Marshal.WriteSingle(d, CInt(offset), i)
            Catch
                Dim t() As Byte = Nothing
                t = single_bytes(i)
                memcpy(d, offset, t)
            End Try
#Else
            Dim t() As Byte = Nothing
            t = single_bytes(i)
            memcpy(d, offset, t)
#End If
#End If
            offset += sizeof_single
            Return True
        Else
            Return False
        End If
    End Function

    Public Function single_bytes(ByVal i As Single) As Byte()
#If IS_BYTE Then
        assert(sizeof_single = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function
'finish bytes_independent_types_impl.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with bytes_independent_types_impl.vbp ----------
'so change bytes_independent_types_impl.vbp instead of this file



#Const IS_BYTE = ("double" = "byte")

    Public Function bytes_double(
                        ByVal i() As Byte,
                        ByVal ii As UInt32,
                        ByVal il As UInt32,
                        ByRef o As Double) As Boolean
        If il <> sizeof_double OrElse array_size(i) < ii + il Then
            Return False
        Else
#If IS_BYTE Then
            o = i(CInt(ii))
#Else
            o = BitConverter.ToDouble(i, CInt(ii))
#End If
            Return True
        End If
    End Function

    Public Function bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(i) >= offset + sizeof_int8 Then
#If IS_BYTE Then
            o = i(CInt(offset))
#Else
            o = BitConverter.ToDouble(i, CInt(offset))
#End If
            offset += sizeof_double
            Return True
        Else
            Return False
        End If
    End Function

    Public Function bytes_double(
                        ByVal i() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Double
        Dim o As Double = 0
        assert(bytes_double(i, o, offset))
        Return o
    End Function

    Public Function entire_bytes_double(
                        ByVal i() As Byte,
                        ByRef o As Double) As Boolean
        Dim p As UInt32 = 0
        Return bytes_double(i, o, p) AndAlso
               p = array_size(i)
    End Function

    Public Function entire_bytes_double(ByVal i() As Byte) As Double
        Dim o As Double = 0
        assert(entire_bytes_double(i, o))
        Return o
    End Function
    
    Public Function double_bytes(
                        ByVal i As Double,
                        ByVal d() As Byte,
                        Optional ByRef offset As UInt32 = uint32_0) As Boolean
        If array_size(d) >= offset + sizeof_double Then
#If IS_BYTE Then
            d(CInt(offset)) = i
#Else
#If 0 Then
            'for mono
            'Marshal.WriteXXX is 100% slower than BitConverter with memcpy
            Try
                Marshal.WriteDouble(d, CInt(offset), i)
            Catch
                Dim t() As Byte = Nothing
                t = double_bytes(i)
                memcpy(d, offset, t)
            End Try
#Else
            Dim t() As Byte = Nothing
            t = double_bytes(i)
            memcpy(d, offset, t)
#End If
#End If
            offset += sizeof_double
            Return True
        Else
            Return False
        End If
    End Function

    Public Function double_bytes(ByVal i As Double) As Byte()
#If IS_BYTE Then
        assert(sizeof_double = uint32_1)
        Dim o() As Byte = Nothing
        ReDim o(0)
        o(0) = i
        Return o
#Else
        Return BitConverter.GetBytes(i)
#End If
    End Function
'finish bytes_independent_types_impl.vbp --------
End Module
'finish bytes_independent_types.vbp --------
