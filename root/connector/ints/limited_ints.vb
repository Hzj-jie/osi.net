
Option Explicit On
Option Infer Off
Option Strict On

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints.vbp ----------
'so change limited_ints.vbp instead of this file


Imports System.Runtime.CompilerServices
Imports osi.root.constants

Public Module _limited_ints


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "SByte" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As SByte) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As SByte)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As SByte) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As SByte) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As SByte) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As SByte) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "SByte" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As SByte) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As SByte) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As SByte)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As SByte)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As SByte) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As SByte) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As SByte) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As SByte) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As SByte) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As SByte) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "SByte" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As SByte) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As SByte) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As SByte) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As SByte) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As SByte)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As SByte)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As SByte)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As SByte)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As SByte) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As SByte) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As SByte) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As SByte) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As SByte) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As SByte) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As SByte) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As SByte) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As SByte) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As SByte) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As SByte) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As SByte) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "Int16" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As Int16) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As Int16)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As Int16) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As Int16) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As Int16) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As Int16) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "Int16" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As Int16) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As Int16) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As Int16)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As Int16)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As Int16) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As Int16) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As Int16) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As Int16) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As Int16) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As Int16) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "Int16" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As Int16) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As Int16) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As Int16) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As Int16) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As Int16)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As Int16)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As Int16)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As Int16)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As Int16) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As Int16) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As Int16) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As Int16) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As Int16) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As Int16) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As Int16) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As Int16) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As Int16) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As Int16) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As Int16) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As Int16) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "Int32" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As Int32) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As Int32)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As Int32) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As Int32) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As Int32) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As Int32) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "Int32" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As Int32) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As Int32) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As Int32)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As Int32)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As Int32) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As Int32) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As Int32) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As Int32) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As Int32) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As Int32) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "Int32" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As Int32) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As Int32) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As Int32) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As Int32) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As Int32)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As Int32)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As Int32)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As Int32)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As Int32) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As Int32) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As Int32) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As Int32) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As Int32) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As Int32) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As Int32) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As Int32) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As Int32) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As Int32) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As Int32) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As Int32) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "Int64" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As Int64) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As Int64)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As Int64) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As Int64) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As Int64) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As Int64) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "Int64" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As Int64) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As Int64) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As Int64)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As Int64)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As Int64) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As Int64) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As Int64) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As Int64) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As Int64) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As Int64) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "Int64" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As Int64) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As Int64) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As Int64) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As Int64) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As Int64)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As Int64)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As Int64)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As Int64)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As Int64) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As Int64) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As Int64) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As Int64) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As Int64) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As Int64) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As Int64) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As Int64) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As Int64) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As Int64) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As Int64) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As Int64) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "Decimal" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As Decimal) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As Decimal)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As Decimal) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As Decimal) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As Decimal) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As Decimal) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "Decimal" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As Decimal) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As Decimal) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As Decimal)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As Decimal)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As Decimal) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As Decimal) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As Decimal) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As Decimal) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As Decimal) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As Decimal) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "Decimal" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As Decimal) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As Decimal) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As Decimal) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As Decimal) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As Decimal)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As Decimal)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As Decimal)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As Decimal)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As Decimal) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As Decimal) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As Decimal) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As Decimal) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As Decimal) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As Decimal) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As Decimal) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As Decimal) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As Decimal) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As Decimal) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As Decimal) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As Decimal) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "Byte" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As Byte) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As Byte)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As Byte) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As Byte) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As Byte) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As Byte) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "Byte" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As Byte) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As Byte) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As Byte)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As Byte)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As Byte) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As Byte) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As Byte) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As Byte) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As Byte) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As Byte) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "Byte" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As Byte) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As Byte) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As Byte) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As Byte) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As Byte)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As Byte)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As Byte)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As Byte)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As Byte) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As Byte) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As Byte) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As Byte) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As Byte) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As Byte) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As Byte) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As Byte) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As Byte) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As Byte) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As Byte) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As Byte) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "UInt16" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As UInt16) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As UInt16)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As UInt16) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As UInt16) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As UInt16) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As UInt16) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "UInt16" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As UInt16) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As UInt16) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As UInt16)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As UInt16)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As UInt16) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As UInt16) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As UInt16) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As UInt16) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As UInt16) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As UInt16) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "UInt16" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As UInt16) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As UInt16) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As UInt16) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As UInt16) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As UInt16)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As UInt16)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As UInt16)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As UInt16)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As UInt16) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As UInt16) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As UInt16) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As UInt16) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As UInt16) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As UInt16) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As UInt16) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As UInt16) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As UInt16) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As UInt16) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As UInt16) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As UInt16) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "UInt32" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As UInt32) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As UInt32)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As UInt32) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As UInt32) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As UInt32) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As UInt32) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "UInt32" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As UInt32) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As UInt32) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As UInt32)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As UInt32)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As UInt32) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As UInt32) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As UInt32) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As UInt32) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As UInt32) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As UInt32) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "UInt32" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As UInt32) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As UInt32) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As UInt32) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As UInt32) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As UInt32)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As UInt32)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As UInt32)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As UInt32)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As UInt32) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As UInt32) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As UInt32) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As UInt32) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As UInt32) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As UInt32) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As UInt32) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As UInt32) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As UInt32) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As UInt32) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As UInt32) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As UInt32) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------


'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_types.vbp ----------
'so change limited_ints_types.vbp instead of this file



'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_timeout.vbp ----------
'so change limited_ints_timeout.vbp instead of this file



' Represent a timeout. Can be infinite.

#If "UInt64" = "SByte" Then
    Public Const timeout_inf As Int32 = npos
#End If

    <Extension()> Public Function is_timeout(ByVal i As UInt64) As Boolean
        Return i >= 0 OrElse i = timeout_inf
    End Function

    <Extension()> Public Sub assert_is_timeout(ByVal i As UInt64)
        assert(i.is_timeout())
    End Sub

    <Extension()> Public Function infinite_timeout(ByVal i As UInt64) As Boolean
        i.assert_is_timeout()
        Return i = timeout_inf
    End Function

    <Extension()> Public Function finite_timeout(ByVal i As UInt64) As Boolean
        i.assert_is_timeout()
        Return i <> timeout_inf
    End Function

    <Extension()> Public Function timeout_ms(ByVal i As UInt64) As UInt32
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint32
        Else
            Return CUInt(i)
        End If
    End Function

    <Extension()> Public Function timeout_ticks(ByVal i As UInt64) As UInt64
        i.assert_is_timeout()
        If i.infinite_timeout() Then
            Return max_uint64
        Else
            Return CULng(i)
        End If
    End Function

'finish limited_ints_timeout.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_offset.vbp ----------
'so change limited_ints_offset.vbp instead of this file



' Represent an offset. Can be invalid.
' int_offset is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' offset is for file or stream. Typically there is no size limitation for these resources.

#If "UInt64" = "SByte" Then
    Public Const offset_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_offset(ByVal i As UInt64) As Boolean
        Return i >= 0 OrElse i = offset_invalid
    End Function

    <Extension()> Public Function is_int_offset(ByVal i As UInt64) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = offset_invalid
    End Function

    <Extension()> Public Sub assert_is_offset(ByVal i As UInt64)
        assert(i.is_offset())
    End Sub

    <Extension()> Public Sub assert_is_int_offset(ByVal i As UInt64)
        assert(i.is_int_offset())
    End Sub

    <Extension()> Public Function invalid_offset(ByVal i As UInt64) As Boolean
        i.assert_is_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function invalid_int_offset(ByVal i As UInt64) As Boolean
        i.assert_is_int_offset()
        Return i = offset_invalid
    End Function

    <Extension()> Public Function valid_offset(ByVal i As UInt64) As Boolean
        i.assert_is_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function valid_int_offset(ByVal i As UInt64) As Boolean
        i.assert_is_int_offset()
        Return i <> offset_invalid
    End Function

    <Extension()> Public Function offset(ByVal i As UInt64) As UInt64
        i.assert_is_offset()
        assert(i.valid_offset())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_offset(ByVal i As UInt64) As Int32
        i.assert_is_int_offset()
        assert(i.valid_int_offset())
        Return CInt(i)
    End Function

'finish limited_ints_offset.vbp --------

'the following code is generated by /osi/root/codegen/precompile/precompile.exe
'with limited_ints_size.vbp ----------
'so change limited_ints_size.vbp instead of this file



' Represent a size. Can be invalid.
' int_size is for memory buffer. Allocating a byte array larger than 2G is not supported in .Net.
' size is for file or stream. Typically there is no size limitation for these resources.

#If "UInt64" = "SByte" Then
    Public Const size_invalid As Int32 = npos
#End If

    <Extension()> Public Function is_size(ByVal i As UInt64) As Boolean
        Return i >= 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_int_size(ByVal i As UInt64) As Boolean
        Return (i >= 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_size(ByVal i As UInt64) As Boolean
        Return i > 0 OrElse i = size_invalid
    End Function

    <Extension()> Public Function is_positive_int_size(ByVal i As UInt64) As Boolean
        Return (i > 0 AndAlso i <= max_int32) OrElse i = size_invalid
    End Function

    <Extension()> Public Sub assert_is_size(ByVal i As UInt64)
        assert(i.is_size())
    End Sub

    <Extension()> Public Sub assert_is_int_size(ByVal i As UInt64)
        assert(i.is_int_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_size(ByVal i As UInt64)
        assert(i.is_positive_size())
    End Sub

    <Extension()> Public Sub assert_is_positive_int_size(ByVal i As UInt64)
        assert(i.is_positive_int_size())
    End Sub

    <Extension()> Public Function invalid_size(ByVal i As UInt64) As Boolean
        i.assert_is_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_int_size(ByVal i As UInt64) As Boolean
        i.assert_is_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_size(ByVal i As UInt64) As Boolean
        i.assert_is_positive_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function invalid_positive_int_size(ByVal i As UInt64) As Boolean
        i.assert_is_positive_int_size()
        Return i = size_invalid
    End Function

    <Extension()> Public Function valid_size(ByVal i As UInt64) As Boolean
        i.assert_is_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_int_size(ByVal i As UInt64) As Boolean
        i.assert_is_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_size(ByVal i As UInt64) As Boolean
        i.assert_is_positive_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function valid_positive_int_size(ByVal i As UInt64) As Boolean
        i.assert_is_positive_int_size()
        Return i <> size_invalid
    End Function

    <Extension()> Public Function size(ByVal i As UInt64) As UInt64
        i.assert_is_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function int_size(ByVal i As UInt64) As Int32
        i.assert_is_int_size()
        assert(i.valid_int_size())
        Return CInt(i)
    End Function

    <Extension()> Public Function positive_size(ByVal i As UInt64) As UInt64
        i.assert_is_positive_size()
        assert(i.valid_size())
        Return CULng(i)
    End Function

    <Extension()> Public Function positive_int_size(ByVal i As UInt64) As Int32
        i.assert_is_positive_int_size()
        assert(i.valid_positive_int_size())
        Return CInt(i)
    End Function

'finish limited_ints_size.vbp --------
'finish limited_ints_types.vbp --------

End Module
'finish limited_ints.vbp --------
