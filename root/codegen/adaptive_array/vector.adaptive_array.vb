'this file is generated by /osi/root/codegen/adaptive_array/adaptive_array.exe
'so change /osi/root/codegen/adaptive_array/adaptive_array.cs instead of this file
'usually you do not need to use this codegen and the code generated unless it's in a very strict performance related code
'use vector is a better way, while the implementation of vector is also using the code generated by this codegen
'p.s. this file needs to work with osi.root.connector project

Imports osi.root
Imports osi.root.connector
Imports osi.root.constants

Partial Public Class vector(Of T)
Private Class adaptive_array_t
    Implements ICloneable, IComparable(Of adaptive_array_t), IComparable

    Private Const size_limitation As UInt32 = (max_uint32 >> 1)
    Private Shared ReadOnly default_value As T = Nothing

    Private Shared Function expected_capacity(ByVal n As UInt32) As UInt32
        If n <= 2 Then
            Return 4
        Else
            Return n << 1
        End If
    End Function

    Private d() As T
    Private s As UInt32

    Public Sub New()
    End Sub

    Public Sub New(ByVal n As UInt32)
        reserve(n)
    End Sub

    Private Sub New(ByVal d() As T, ByVal s As UInt32)
        Me.d = d
        Me.s = s
    End Sub

    Public Shared Function move(ByVal that As adaptive_array_t) As adaptive_array_t
        If that Is Nothing Then
            Return Nothing
        Else
            Dim r As adaptive_array_t = Nothing
            r = New adaptive_array_t()
            move_to(that, r)
            Return r
        End If
    End Function

    Protected Shared Sub move_to(ByVal this As adaptive_array_t, ByVal that As adaptive_array_t)
        assert(Not this Is Nothing)
        assert(Not that Is Nothing)
        that.d = this.d
        that.s = this.s
        this.d = Nothing
        this.s = 0
    End Sub

    Public Shared Function swap(ByVal this As adaptive_array_t, ByVal that As adaptive_array_t) As Boolean
        If this Is Nothing OrElse that Is Nothing Then
            Return False
        Else
            connector.swap(this.d, that.d)
            connector.swap(this.s, that.s)
            Return True
        End If
    End Function

    Public Function clone() As adaptive_array_t
        Dim r As adaptive_array_t
        r = New adaptive_array_t
        clone_to(Me, r)
        Return r
    End Function

    Protected Shared Sub clone_to(ByVal this As adaptive_array_t, ByVal that As adaptive_array_t)
        assert(Not this Is Nothing)
        assert(Not that Is Nothing)
        that.resize(this.size())
        If Not this.empty() Then
            For i As UInt32 = 0 To this.size() - uint32_1
                copy(that.d(i), this.d(i))
            Next
        End If
    End Sub

    Public Function max_size() As UInt32
        Return size_limitation
    End Function

    Public Function data() As T()
        Return d
    End Function

    Default Public Property at(ByVal p As UInt32) As T
        Get
            Return d(p)
        End Get
        Set(ByVal value As T)
            d(p) = value
        End Set
    End Property

    Public Function [get](ByVal p As UInt32) As T
        Return d(p)
    End Function

    Public Sub [set](ByVal p As UInt32, ByVal v As T)
        d(p) = v
    End Sub

    Public Function size() As UInt32
        Return s
    End Function

    Public Function empty() As Boolean
        Return size() = uint32_0
    End Function

    Public Function capacity() As UInt32
        Return array_size(d)
    End Function

    Public Function back() As T
        Return d(size() - uint32_1)
    End Function

    Public Sub clear()
        If size() > uint32_0 Then
            memclr(d, uint32_0, s)
            s = uint32_0
        End If
    End Sub

    Public Sub push_back(ByVal v As T)
        reserve(size() + uint32_1)
        d(size()) = v
        s += uint32_1
    End Sub

    Public Sub pop_back()
        s -= uint32_1
        d(size()) = default_value
    End Sub

    Public Sub reserve(ByVal n As UInt32)
        If capacity() < n Then
            If empty() Then
                ReDim d(expected_capacity(n) - uint32_1)
            Else
                ReDim Preserve d(expected_capacity(n) - uint32_1)
            End If
        End If
    End Sub

    Public Sub resize(ByVal n As UInt32)
        If capacity() < n Then
            reserve(n)
        ElseIf size() > n Then
            memclr(d, n, size() - n)
        End If
        s = n
    End Sub

    Public Sub resize(ByVal n As UInt32, ByVal v As T)
        Dim os As UInt32 = 0
        os = size()
        If n > os Then
            resize(n)
            memset(d, os, n - os, v)
        Else
            resize(n)
        End If
    End Sub

    Public Sub shrink_to_fit()
        If empty() Then
            ReDim d(-1)
        ElseIf capacity() > size() Then
            ReDim Preserve d(size() - uint32_1)
        End If
    End Sub

    Public Function ICloneable_Clone() As Object Implements ICloneable.Clone
        Return clone()
    End Function

    Public Shared Function compare(ByVal this As adaptive_array_t, ByVal that As adaptive_array_t) As Int32
        Dim c As Int32 = 0
        c = object_compare(this, that)
        If c = object_compare_undetermined Then
            assert(Not this Is Nothing)
            assert(Not that Is Nothing)
            If this.size() < that.size() Then
                Return -1
            ElseIf this.size() > that.size() Then
                Return 1
            Else
                Return memcmp(this.d, that.d, this.size())
            End If
        Else
            Return c
        End If
    End Function

    Public Function CompareTo(ByVal obj As Object) As Int32 Implements IComparable.CompareTo
        Return CompareTo(cast(Of adaptive_array_t)(obj, False))
    End Function

    Public Function CompareTo(ByVal other As adaptive_array_t) As Int32 Implements IComparable(Of adaptive_array_t).CompareTo
        Return compare(Me, other)
    End Function

End Class
End Class
